package streamcomponents

import akka.NotUsed
import akka.stream.SourceShape
import akka.stream.scaladsl.{Concat, GraphDSL, Source}
import akka.util.ByteString
import helpers.RangeHeader

object MultipartSource {
  /**
    * generates a 10-character random string used as a section boundary
    * @return the string
    */
  protected def genSeparatorText: String = {
    val length = 10
    val r = new scala.util.Random
    val a = new Array[Char](length)
    val sb = new StringBuilder
    for (i <- 0 until length) {
      a(i) = r.nextPrintableChar
    }
    a.mkString
  }

  /**
    * builds a single streaming Source for a multipart from the list of sources and ranges provided.
    * @param ranges sequence of ranges
    * @param sources sequence of sources, corresponding to each range. if these sequences are different lengths then it's an error
    * @param totalSize total size of the streaming file, for building headers
    * @param contentType content-type of the streaming file.
    * @return a single Source[ByteString,NotUsed] that will yield the multipart response body
    */
  def getSource(ranges:Seq[RangeHeader], sources:Seq[Source[ByteString,NotUsed]], totalSize:Long, contentType:String) = {
    val separator = genSeparatorText
    var n=0
    val fullSourcesList:Seq[Source[ByteString,NotUsed]] = ranges.foldLeft[Seq[Source[ByteString, NotUsed]]](Seq())((acc,entry)=>{
      n+=1
      acc++Seq(
        Source.single(makeSectionHeader(entry, totalSize, contentType, separator)),
        sources(n-1)

      )
    }) ++ Seq(Source.single(ByteString(s"--$separator--")))
    Source.combine(fullSourcesList.head, fullSourcesList.tail.head, fullSourcesList.tail.tail:_*)(Concat(_))
  }

  /**
    * returns a ByteString of an individual section header, consisting of the top separator, Content-Type and Content-Range headers.
    * @param range [[RangeHeader]] instance giving the range that this section represents
    * @param totalSize total size of the streamed file
    * @param contentType content type of the streamed file
    * @param separator the seperator string, generated by `genSeperatorText`. This must be the same for all parts of the response
    * @return a ByteString containing the header
    */
  protected def makeSectionHeader(range:RangeHeader, totalSize:Long, contentType:String, separator:String):ByteString = {
    val absRange = range.getAbsolute(totalSize)
    ByteString(s"""
      |--$separator
      |Content-Type: $contentType
      |Content-Range: bytes ${absRange._1}-${absRange._2}/$totalSize
    """.stripMargin.replace("\n","\r\n"))
  }
}
