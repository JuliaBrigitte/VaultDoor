package streamcomponents

import akka.NotUsed
import akka.stream.SourceShape
import akka.stream.scaladsl.{Concat, GraphDSL, Source}
import akka.util.ByteString
import helpers.RangeHeader
import helpers.RandomExtender._

object MultipartSource {

  /**
    * generates a 10-character random string used as a section boundary
    * @return the string
    */
  def genSeparatorText: String = {
    val length = 10
    val r = new scala.util.Random
    val a = new Array[Char](length)
    for (i <- 0 until length) {
      a(i) = r.nextAlphaChar
    }
    a.mkString
  }

  /**
    * builds a single streaming Source for a multipart from the list of sources and ranges provided.
    * @param rangeAndSource sequence of tuples, each has a RangeHeader representing the range and a Source that will grab the byte content of said range.
    * @param totalSize total size of the streaming file, for building headers
    * @param contentType content-type of the streaming file.
    * @param separator randomised section separator text. Get this by calling `MultipartSource.genSeparatorText`.
    * @return a single Source[ByteString,NotUsed] that will yield the multipart response body
    */
  //def getSource(ranges:Seq[RangeHeader], sources:Seq[Source[ByteString,NotUsed]], totalSize:Long, contentType:String, separator:String) = {
  def getSource(rangeAndSource:Seq[(RangeHeader, Source[ByteString,NotUsed])], totalSize:Long, contentType:String, separator:String) = {
    var n=0

    val fullSourcesList:Seq[Source[ByteString,NotUsed]] = rangeAndSource.foldLeft[Seq[Source[ByteString, NotUsed]]](Seq())((acc,entry)=>{
      n+=1
      acc++Seq(
        Source.single(makeSectionHeader(entry._1, totalSize, contentType, separator)),
        entry._2
      )
    }) ++ Seq(Source.single(ByteString(s"\r\n--$separator--")))
    Source.combine(fullSourcesList.head, fullSourcesList.tail.head, fullSourcesList.tail.tail:_*)(Concat(_))
  }

  /**
    * returns a ByteString of an individual section header, consisting of the top separator, Content-Type and Content-Range headers.
    * @param range [[RangeHeader]] instance giving the range that this section represents
    * @param totalSize total size of the streamed file
    * @param contentType content type of the streamed file
    * @param separator the seperator string, generated by `genSeperatorText`. This must be the same for all parts of the response
    * @return a ByteString containing the header
    */
  def makeSectionHeader(range:RangeHeader, totalSize:Long, contentType:String, separator:String):ByteString = {
    val absRange = range.getAbsolute(totalSize)
    ByteString(s"""
      |--$separator
      |Content-Type: $contentType
      |Content-Range: bytes ${absRange._1}-${absRange._2}/$totalSize
      |
      |""".stripMargin.replace("\n","\r\n"))
  }
}
